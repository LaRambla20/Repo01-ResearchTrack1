<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>First RT1 Assignment: First Reasearch Track 1 Assignment</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">First RT1 Assignment
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">First Reasearch Track 1 Assignment </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The folder in which this README is contains three subfolders, two python scripts and a markdown file (.md):</p><ul>
<li><code>sr</code> and <code>games</code>: folders that contain everything that the used simulator needs to be run</li>
<li><code>dox</code>: folder that contains the documentation generated by the software doxygen based on the comments in the code</li>
<li><code><a class="el" href="assignment1_8py.html" title="This file contains one possible solution to the first RT1 assignment.">assignment1.py</a></code>: python script that implements the resolution to the presented problem</li>
<li><code>run.py</code>: python script that allows the running of python scripts on the simulator</li>
<li><code>LICENSE.md</code>: markdown file that contains the licence of the used software</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
How to run</h1>
<p>The simulator used to see the effects of the python script at issue is named Python Robotic Simulator. This is a simple and portable robot simulator developed by <a href="https://studentrobotics.org">Student Robotics</a>.</p>
<p>The simulator requires a Python 2.7 installation, the <a href="http://pygame.org/">pygame</a> library, <a href="https://pypi.python.org/pypi/pypybox2d/2.1-r331">PyPyBox2D</a>, and <a href="https://pypi.python.org/pypi/PyYAML/">PyYAML</a>.</p>
<p>Python scripts can be run in the simulator using <code>run.py</code> and passing it the file name. In this particular case the command is the following:</p>
<div class="fragment"><div class="line">$ python run.py assignment1.py</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
About the Simulator: Robot API</h2>
<p>The robot simulated in the simulator is controlled by an API that is designed to be as similar as possible to the <a href="https://studentrobotics.org/docs/programming/sr/">SR API</a>. The features of the controlling API are the following:</p>
<p><b>Motors</b></p>
<p>The simulated robot has two motors configured for skid steering, connected to a two-output <a href="https://studentrobotics.org/docs/kit/motor_board">Motor Board</a>. The left motor is connected to output <code>0</code> and the right motor to output <code>1</code>.</p>
<p>The Motor Board API is identical to <a href="https://studentrobotics.org/docs/programming/sr/motors/">that of the SR API</a>, except that motor boards cannot be addressed by serial number. So, to turn on the spot at one quarter of full power, one might write the following:</p>
<div class="fragment"><div class="line">R.motors[0].m0.power = 25</div>
<div class="line">R.motors[0].m1.power = -25</div>
</div><!-- fragment --><p><b>Grabber</b></p>
<p>The robot is equipped with a grabber, capable of picking up a token which is in front of the robot and within 0.4 metres of the robot's centre. To pick up a token, call the <code>R.grab</code> method:</p>
<div class="fragment"><div class="line">success = R.grab()</div>
</div><!-- fragment --><p>The <code>R.grab</code> function returns <code>True</code> if a token was successfully picked up, or <code>False</code> otherwise. If the robot is already holding a token, it will throw an <code>AlreadyHoldingSomethingException</code>.</p>
<p>To drop the token, call the <code>R.release</code> method.</p>
<p>Cable-tie flails are not implemented.</p>
<p><b>Vision</b></p>
<p>To help the robot find tokens and navigate, each token has markers stuck to it, as does each wall. The <code>R.see</code> method returns a list of all the markers the robot can see, as <code>Marker</code> objects. The robot can see markers around it within a certain distance.</p>
<p>Each <code>Marker</code> object has the following attributes:</p>
<ul>
<li><code>info</code>: a <code>MarkerInfo</code> object describing the marker itself. Has the following attributes:<ul>
<li><code>code</code>: the numeric code of the marker.</li>
<li><code>marker_type</code>: the type of object the marker is attached to (either <code>MARKER_TOKEN_GOLD</code>, <code>MARKER_TOKEN_SILVER</code> or <code>MARKER_ARENA</code>).</li>
<li><code>offset</code>: offset of the numeric code of the marker from the lowest numbered marker of its type. For example, token number 3 has the code 43, but offset 3.</li>
<li><code>size</code>: the size that the marker would be in the real game, for compatibility with the SR API.</li>
</ul>
</li>
<li><code>centre</code>: the location of the marker in polar coordinates, as a <code>PolarCoord</code> object. Has the following attributes:<ul>
<li><code>length</code>: the distance from the centre of the robot to the object (in metres).</li>
<li><code>rot_y</code>: rotation about the Y axis in degrees.</li>
</ul>
</li>
<li><code>dist</code>: an alias for <code>centre.length</code></li>
<li><code>res</code>: the value of the <code>res</code> parameter of <code>R.see</code>, for compatibility with the SR API.</li>
<li><code>rot_y</code>: an alias for <code>centre.rot_y</code></li>
<li><code>timestamp</code>: the time at which the marker was seen (when <code>R.see</code> was called).</li>
</ul>
<p><b>Heading</b></p>
<p>The <code>sr.robot</code> library contains support for using a simulated compass unit on the robot. This allows robots to determine the direction it is facing in the arena. </p><div class="fragment"><div class="line">from sr.robot import *</div>
<div class="line">R = Robot()</div>
<div class="line">heading = R.heading</div>
</div><!-- fragment --><p>When called, the heading method will return the heading of the robot as a float. The heading is in the range -3 to 3, where -3 is the robot facing directly West, and values increasing counter-clockwise.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Script goal</h1>
<p>Once the script is run, it will appear an arena with several square blocks (either golden or silver) and the simulated robot in the upper-left corner. The goal of the script is to guide the robot along the path defined by the golden blocks in counter-clockwise direction, making sure that it doesn't collide with them. Furthermore the robot has to grab the silver blocks that it encounters along the way and move them behind itself.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Idea - Robot behaviour</h1>
<p>In order to achieve the goal stated above, the simulated robot has to:</p><ul>
<li>detect the silver boxes in front of it and move them</li>
<li>recognize when it is dangerously near a golden box and change direction accordingly</li>
</ul>
<p>As far as the detection task is concerned, the method of the <code>Robot</code> class that should be used is the <code>R.see</code>. As stated above, thanks to this method, the robot sees blocks around it within a certain distance. The idea is to limit this circular area in order to retrieve the information that the robot needs to move properly in the space. The adopted solution to accomplish that is described in the following picture: <br  />
 <img src="https://user-images.githubusercontent.com/91536387/140644164-46320949-0a9e-4663-b170-e6bc68a35287.png" alt="Robot_RT1" class="inline"/> <br  />
 First of all the robot should detect silver tokens. In order to do that, the visual field is limited to a circular sector, 180 degrees wide and with a <code>sil_th</code> radius. These quantities are evaluated so as to make it possible for the robot to find silver boxes, no matter its position in the lane. Once a silver token is detected, the robot aligns with it, moves close to it, grabs it, moves it behind itself and realeases it. <br  />
 Regarding the recognition of dangerous golden tokens instead, the visual field is restricted to a circular sector, 80 degrees wide and with a <code>dan_th</code> radius. If at least one golden box is inside this sector, the robot stops and checks where to turn to avoid collision. This check is run using two different approches. The first one is based on the fact that usually, once dangerous golden blocks are detected, the robot should turn right or left according to the side where the number of near golden blocks is smaller. Thus the visual field is limited to a circular sector, 270 degrees wide and with a <code>near_th</code> radius. This particular angular width is chosen so as to prevent the robot from seeing the golden boxes behind itself, since they will just ruin the accuracy of the estimate. There are specific cases, though, in which the number of near golden tokens on the right is equal to the number of near golden tokens on the left, and then the first method will not work properly. For this reason the second approach must be considered. This simply consists in checking the distance between the robot and the nearest golden token on the left, and in checking the distance between the robot and the nearest golden token on the right. In order to carry out this task, the visual field is restricted to two circular sectors, one ranging from 75 degrees to 105 degrees with no limit on the radius, and the other ranging from -105 degrees to -75 degrees with no limit on the radius. Naturally, once the condition to resort to this second solution is verified, the robot should turn right or left according to the side where the distance from the nearest golden token is greater.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Implementation - Code description</h1>
<p>The idea presented above was implemented with a python script structured in a main function and six additional functions: <code>drive(speed, seconds)</code>, <code>turn(speed, seconds)</code>, <code><a class="el" href="assignment1_8py.html#a10b970bb96f5c166b7183a0c5bfc6458" title="Function to check if there are any golden tokens within a certain distance (dan_th) in a certain angu...">check_dangerous_tokens()</a></code>, <code><a class="el" href="assignment1_8py.html#a52ccf0ec210201d1e370a3d27a848c87" title="Function to count the number of golden tokens on the left and on the right of the robot within a cert...">count_tokens()</a></code>, <code>change_direction(n_left_tokens, n_right_tokens)</code>, <code><a class="el" href="assignment1_8py.html#a106fed3e0da3aed8d57c18ca6cb5701e" title="Function to detect if there are any silver tokens within a certain distance (sil_th) in a certain ang...">detect_silver_tokens()</a></code>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Functions</h2>
<p>The first function can be described in pseudocode as follows: </p><div class="fragment"><div class="line">drive(speed, seconds):</div>
<div class="line">    set the speed of both robot wheels to a certain speed for a certain number of seconds</div>
</div><!-- fragment --><p>The second function can be described in pseudocode as follows: </p><div class="fragment"><div class="line">turn(speed, seconds):</div>
<div class="line">    set the speed of one of the robot wheels to a certain speed and the other to the opposite of that speed for a certain number of seconds</div>
</div><!-- fragment --><p>The third function can be described in pseudocode as follows: </p><div class="fragment"><div class="line">check_dangerous_tokens():</div>
<div class="line">    initialize the number of dangerous golden tokens to 0</div>
<div class="line">    retrieve the tokens around the robot within a certain distance with the R.see method</div>
<div class="line">    for i spanning the tokens just detected:</div>
<div class="line">        if (the token is gold) and (the distance from the robot is less than or equal to dan_th=0.9) and (the angular displacement between the robot and the token is between -per_dan_th=-40 and per_dan_th=40):</div>
<div class="line">            increment the number of dangerous golden tokens</div>
<div class="line">    return the number of dangerous golden tokens</div>
</div><!-- fragment --><p>The fourth function can be described in pseudocode as follows: </p><div class="fragment"><div class="line">count_tokens():</div>
<div class="line">    initialize the number of near golden tokens on the left to 0</div>
<div class="line">    initialize the number of near golden tokens on the right to 0</div>
<div class="line">    retrieve the tokens around the robot within a certain distance with the R.see method</div>
<div class="line">    for i spanning the tokens just detected:</div>
<div class="line">        if (the token is gold) and (the distance from the robot is less than or equal to near_th=1.6) and (the angular displacement between the robot and the token is between -per_near_th=-135 and per_near_th=135):</div>
<div class="line">            if the angualar displacement between the robot and the token is less than or equal to 0:</div>
<div class="line">                increment the number of near golden tokens on the left</div>
<div class="line">            else:</div>
<div class="line">                increment the number of near golden tokens on the right</div>
<div class="line">    return the number of near golden tokens on the left and the number of near golden tokens on the right</div>
</div><!-- fragment --><p>The fifth function can be described in pseudocode as follows: </p><div class="fragment"><div class="line">change_direction(n_left_tokens, n_right_tokens):</div>
<div class="line">    initialize the nearest wall distance to 100</div>
<div class="line">    if the number of left tokens is greater than the number of right tokens:</div>
<div class="line">        turn right a little</div>
<div class="line">    elif the number of left tokens is less than the number of right tokens:</div>
<div class="line">        turn left a little</div>
<div class="line">    elif the number of left tokens is equal to the number of right tokens:</div>
<div class="line">        retrieve the tokens around the robot within a certain distance with the R.see method</div>
<div class="line">        for i spanning the tokens just detected</div>
<div class="line">            if (the token is gold) and ((the angular displacement between the robot and the token is between -per_wall_th2=-105 and -per_wall_th1=-75) or (the angular displacement between the robot and the token is between per_wall_th1=75 and per_wall_th2=105)):</div>
<div class="line">                if the distance from the robot is less than or equal to the nearest wall distance:</div>
<div class="line">                    update the nearest wall distance</div>
<div class="line">                    update the nearest wall angular displacement</div>
<div class="line">        if the nearest wall angular displacement is less than or equal to 0:</div>
<div class="line">            turn right a little</div>
<div class="line">        else:</div>
<div class="line">            turn left a little</div>
</div><!-- fragment --><p>The sixth function can be described in pseudocode as follows: </p><div class="fragment"><div class="line">detect_silver_tokens():</div>
<div class="line">    initialize the distance from the detected silver token to 100</div>
<div class="line">    retrieve the tokens around the robot within a certain distance with the R.see method</div>
<div class="line">    for i spanning the tokens just detected:</div>
<div class="line">        if (the token is silver) and (the distance from the robot is less than or equal to sil_th=1.2) and (the angular displacement between the robot and the token is between -per_sil_th=-90 and per_sil_th=90):</div>
<div class="line">            update the detected silver token distance</div>
<div class="line">            update the detected silver token angular displacement</div>
<div class="line">    if the detected silver token distance is still 100:</div>
<div class="line">        return -1 and -1</div>
<div class="line">    else:</div>
<div class="line">    return the detected silver token distance and the detected silver token angular displacement</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Main</h2>
<p>The main function can be described in pseudocode as follows:</p>
<div class="fragment"><div class="line">while 1</div>
<div class="line">    go forward a bit, calling the drive function</div>
<div class="line">    retrieve the distance and the angular displacement of the detected silver token, if any, calling the detect_silver_tokens function</div>
<div class="line">    if a silver token was detected:</div>
<div class="line">        if the distance from the silver token is greater than or equal to d_th=0.4:</div>
<div class="line">            while the angular displacement between the robot and the detected silver token is outside the range [-a_th=-2, a_th=2]:</div>
<div class="line">                if the angular displacement between the robot and the detected silver token is less than -a_th=-2:</div>
<div class="line">                    turn left a little</div>
<div class="line">                if the angular displacement between the robot and the detected silver token is greater than a_th=2:</div>
<div class="line">                    turn right a little</div>
<div class="line">                retrieve the distance and the angular displacement of the detected silver token, calling the detect_silver_tokens function</div>
<div class="line">        else:</div>
<div class="line">            Grab the silver token with the R.grab method</div>
<div class="line">            if the grabbing succeeds:</div>
<div class="line">                turn 180 degrees, using the R.heading method</div>
<div class="line">                release the silver token with the R.release method</div>
<div class="line">                step back to avoid hitting the silver token just released</div>
<div class="line">                turn 180 degrees to reset the orientation to the initial one, using the R.heading method</div>
<div class="line">    else:</div>
<div class="line">        retrieve the number of golden tokens dangerously near, calling the check_dangerous_tokens function</div>
<div class="line">        if the number of dangerous golden tokens is not 0:</div>
<div class="line">            while the number of dangerous golden tokens is not 0:</div>
<div class="line">                retrieve the number of near golden tokens on the left and the number of near golden tokens on the right, calling the count_tokens function</div>
<div class="line">                change the direction, calling the change_direction function</div>
<div class="line">                retrieve the number of golden tokens dangerously near, calling the check_dangerous_tokens function</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
System Limitations and Possible Improvements</h1>
<p>As far as the limitations of the script are concerned, mainly two of them can be found. The first one is that the robot, once it has released a silver token, steps back in order to avoid hitting that token while resetting its orientation. This could be a problem if the grabbed silver token was very close to a golden wall, because, while performing the step back, the robot could collide with that wall. A possible solution could be to check the distance from the golden walls as a priority with respect to the silver tokens detection. In this manner, however, it would be possible that silver blocks that are very close to the walls are not picked up by the robot. <br  />
 Another similiar issue concerns the rotation of the robot once it has grabbed a silver token. According to the script, the robot rotates one way or the other based on its initial orientation. However, if the grabbed silver token is too close to a golden wall, the robot could, during its rotation, hit the golden blocks. In order to solve this issue a control on the distance from the nearest wall should be performed and the rotation should be carried out according to that check. <br  />
 A possible improvement could be to implement a solution to this problem that does not rely on the fact that the walls are made of separate blocks. Under these circumstances the check on the number of golden blocks around the robot could not be run and the second approach that is here implemented could result in the robot going back. In order to avoid that, the method <code>R.heading</code> of the class <code>Robot</code> could be used. As a matter of fact, this method could allow the robot to keep track of its orientation and, therefore, to understand when an odd change of orientation occurs.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
System Issues</h1>
<p>When the robot is perfectly aligned with a silver token that it has detected, due to the bulk of its grabber, it never manages to get close to the token enough to grab it. This, however, it is not a script issue, but a simulator issue. <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
