# First Reasearch Track 1 Assignment
The folder in which this README is contains two subfolders and two python scripts:
* `sr`: folder that contains eveything the used simulator needs to be run
* `dox`: folder that contains the documentation generated by the software doxygen based on the comments in the code
* `assignment1.py`: python script that implements the resolution to the presented problem 
* `run.py`: python script that allows the running of python scripts on the simulator

## How to run
The simulator used to see the effects of the python script at issue is named Python Robotic Simulator. This is a simple and portable robot simulator developed by [Student Robotics](https://studentrobotics.org).

The simulator requires a Python 2.7 installation, the [pygame](http://pygame.org/) library, [PyPyBox2D](https://pypi.python.org/pypi/pypybox2d/2.1-r331), and [PyYAML](https://pypi.python.org/pypi/PyYAML/).

Python scripts can be run in the simulator using `run.py` and passing it the file name. In this particular case the command is the following:

```bash
$ python run.py assignment1.py
```

### About the Simulator: Robot API

The robot simulated in the simulator is controlled by an API that is designed to be as similar as possible to the [SR API][sr-api]. The features of the controlling API are the follwing:

**Motors**

The simulated robot has two motors configured for skid steering, connected to a two-output [Motor Board](https://studentrobotics.org/docs/kit/motor_board). The left motor is connected to output `0` and the right motor to output `1`.

The Motor Board API is identical to [that of the SR API](https://studentrobotics.org/docs/programming/sr/motors/), except that motor boards cannot be addressed by serial number. So, to turn on the spot at one quarter of full power, one might write the following:

```python
R.motors[0].m0.power = 25
R.motors[0].m1.power = -25
```

**Grabber**

The robot is equipped with a grabber, capable of picking up a token which is in front of the robot and within 0.4 metres of the robot's centre. To pick up a token, call the `R.grab` method:

```python
success = R.grab()
```

The `R.grab` function returns `True` if a token was successfully picked up, or `False` otherwise. If the robot is already holding a token, it will throw an `AlreadyHoldingSomethingException`.

To drop the token, call the `R.release` method.

Cable-tie flails are not implemented.

**Vision**

To help the robot find tokens and navigate, each token has markers stuck to it, as does each wall. The `R.see` method returns a list of all the markers the robot can see, as `Marker` objects. The robot can only see markers which it is facing towards.

Each `Marker` object has the following attributes:

* `info`: a `MarkerInfo` object describing the marker itself. Has the following attributes:
  * `code`: the numeric code of the marker.
  * `marker_type`: the type of object the marker is attached to (either `MARKER_TOKEN_GOLD`, `MARKER_TOKEN_SILVER` or `MARKER_ARENA`).
  * `offset`: offset of the numeric code of the marker from the lowest numbered marker of its type. For example, token number 3 has the code 43, but offset 3.
  * `size`: the size that the marker would be in the real game, for compatibility with the SR API.
* `centre`: the location of the marker in polar coordinates, as a `PolarCoord` object. Has the following attributes:
  * `length`: the distance from the centre of the robot to the object (in metres).
  * `rot_y`: rotation about the Y axis in degrees.
* `dist`: an alias for `centre.length`
* `res`: the value of the `res` parameter of `R.see`, for compatibility with the SR API.
* `rot_y`: an alias for `centre.rot_y`
* `timestamp`: the time at which the marker was seen (when `R.see` was called).

**Heading**

The sr.robot library contains support for using a simulated compass unit on the robot. This allows robots to determine the direction itâ€™s facing in the arena.
```python
  from sr.robot import *
  R = Robot()
  heading = R.heading
```
When called, the heading method will return the heading of the robot as a float. The heading is in the range -3 to 3, where -3 is the robot facing directly West, and values increasing counter-clockwise.

## Script goal
Once the script is run, it will appear an arena with several square blocks (either golden or silver) and the simulated robot in the upper-left corner. The goal of the script is to guide the robot along the path defined by the golden blocks in counter-clockwise direction, making sure that it doesn't collide with them. Furthermore the robot has to grab the silver blocks that it encounters along the way and move them behind itself.

## Idea - Robot behaviour
In order to achieve the goal stated above, the simulated robot has to:
* detect the silver boxes in front of it and move them
* recognize when it is dangerously near a golden box and change direction accordingly

As far as the detection task is cncerned, the method of the Robot class that should be used is the R.see. As stated above, thanks to this method, the robot sees blocks around it within a certain distance. The idea is to limit this circular area in order to retrieve the information that the robot needs to move properly in the space. The adopted solution to accomplish that is described in the following picture:  
![Robot_RT1](https://user-images.githubusercontent.com/91536387/140644164-46320949-0a9e-4663-b170-e6bc68a35287.png)
First of all the robot should detect silver tokens. In order to do that the visual field is limited to a circular sector, 180 degrees wide and with a sil_th radius. These quantities are evaluated so as to make it possible for the robot to find silver boxes, no matter its position in the lane.  Once a silver token is detected the robot aligns with it, moves close to it, grabs it, moves it behind itself and realeases it.  
Regarding the recognition of dangerous golden tokens instead, the visual field is restricted to a circular sector, 80 degrees wide and with a dan_th radius. If at least one golden box is inside this sector, the robot stops and checks where to turn to avoid collision. This check is run using two different approches. The first one is based on the fact that usually, once dangerous golden blocks are detected, the robot should turn right or left according to the side where the number of near golden blocks is smaller. Thus the visual field is limited to a circular sector, 270 degrees wide and with a near_th radius. This particular angular width is chosen so as to prevent the robot from seeing the golden boxes behind itself, since they will just ruin the accuracy of the estimate. There are specific cases though in which the number of near golden tokens on the right is equal to the number of near golden tokens on the left, and then the first method will not work properly. For this reason the second approach must be considered. This simply consists in checking the distance between the robot and the nearest golden token on the left and the distance between the robot and the nearest golden token on the right. In order to carry out this task the visual field is restricted to two circular sectors, one ranging from 75 degrees and 105 degrees with no limit on the radius, and the other ranging from -105 degrees and -75 degrees with no limit on the radius. Naturally, once the condition to resort to this second solution is verified, the robot should turn right or left according to the side where the distance from the nearest golden token is greater. 

## Implementation - Code description
The code is structured in a main function and 5 additional functions

### Functions
Each `Marker` object has the following attributes:

* `info`: a `MarkerInfo` object describing the marker itself. Has the following attributes:
  * `code`: the numeric code of the marker.
  * `marker_type`: the type of object the marker is attached to (either `MARKER_TOKEN_GOLD`, `MARKER_TOKEN_SILVER` or `MARKER_ARENA`).

```python
R.motors[0].m0.power = 25
R.motors[0].m1.power = -25
```

### Main

## System Limitations and Possible Improvements

[sr-api]: https://studentrobotics.org/docs/programming/sr/
